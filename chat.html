import os
from flask import Flask, request, session, redirect, send_file, jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_socketio import SocketIO, emit
from datetime import datetime
from werkzeug.security import generate_password_hash, check_password_hash
import random

app = Flask(__name__)
app.secret_key = os.environ.get('SECRET_KEY', 'devkey')

# PostgreSQL URI через переменную окружения (например, Render)
app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get("DATABASE_URL")
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

socketio = SocketIO(app)
db = SQLAlchemy(app)

# Модель пользователя
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), unique=True, nullable=False)
    password_hash = db.Column(db.String(128), nullable=False)

# Модель сообщений
class Message(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), nullable=False)
    text = db.Column(db.Text, nullable=False)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)

# Создание таблиц (один раз)
with app.app_context():
    db.create_all()

# Капча (примитивная)
def generate_captcha():
    a, b = random.randint(1, 9), random.randint(1, 9)
    session['captcha'] = str(a + b)
    return f"{a} + {b} = ?"

@app.route('/')
def index():
    return redirect('/reg.html')

@app.route('/reg.html')
def serve_reg():
    return send_file('reg.html')

@app.route('/chat.html')
def serve_chat():
    if 'username' in session:
        return send_file('chat.html')
    return redirect('/reg.html')

@app.route('/captcha')
def captcha():
    return jsonify({"captcha": generate_captcha()})

@app.route('/register', methods=['POST'])
def register():
    data = request.get_json()
    if not all(k in data for k in ('username', 'password', 'captcha')):
        return 'Недостаточно данных', 400
    if data['captcha'] != session.get('captcha'):
        return 'Неверная капча', 400

    if User.query.filter_by(username=data['username']).first():
        return 'Пользователь уже существует', 400

    user = User(
        username=data['username'],
        password_hash=generate_password_hash(data['password'])
    )
    db.session.add(user)
    db.session.commit()
    session['username'] = user.username
    return 'OK'

@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    if not all(k in data for k in ('username', 'password', 'captcha')):
        return 'Недостаточно данных', 400
    if data['captcha'] != session.get('captcha'):
        return 'Неверная капча', 400

    user = User.query.filter_by(username=data['username']).first()
    if not user or not check_password_hash(user.password_hash, data['password']):
        return 'Неверный логин или пароль', 400

    session['username'] = user.username
    return 'OK'

@socketio.on('connect')
def on_connect():
    if 'username' not in session:
        return False

    messages = Message.query.order_by(Message.timestamp.desc()).limit(50).all()
    messages.reverse()
    emit('load_messages', [{"user": m.username, "text": m.text} for m in messages])

@socketio.on('send_message')
def on_message(data):
    username = session.get('username')
    text = data.get('text')
    if not username or not text:
        return
    msg = Message(username=username, text=text)
    db.session.add(msg)
    db.session.commit()
    emit('new_message', {"user": username, "text": text}, broadcast=True)

if __name__ == '__main__':
    socketio.run(app, host='0.0.0.0', port=int(os.environ.get('PORT', 5000)))
